%                                                                                                               
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2011-08-14 17:43:38+02:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

\part{Fonctionnement monotâches}

\begin{frame}{Quelques définitions}
  \begin{itemize}
  \item \textbf{Temps de réponse} : temps entre un évènement et la fin
    du traitement de l'évènement.
  \end{itemize} 
  \note{Nous verrons une formule plus formelle plus tard}
  \note{Exo: Avertir l'utilisateur des qu'un fichier passer en parametre existe: 1: Par polling 2: Par fg/bg}
\end{frame}

\section{Scrutation des évènements}
\begin{frame}[fragile]{Scrutation des évènements}
  \begin{itemize} 
  \item Aussi appellé \emph{polling}
  \item Boucle infinie 
  \item On teste des valeurs des entrées à chaque tour de boucle
  \end{itemize} 
  \begin{lstlisting} 
#define sensor1 *((char *) 0x1234)
#define sensor2 *((char *) 0xABCD)

int main() {
  while (1) {
    if (sensor1)
      action1();
    if (sensor2)
      action2();
  }
}
  \end{lstlisting} 
\end{frame}

\begin{frame}{Scrutation}
  \begin{itemize} 
  \item Temps de réponse au  évènements en pire cas facile à calculer:
    Pire temps pour parcourir la boucle
  \item Simple à programmer lorsqu'il  y a peu de périphériques (ayant
    des temps  de réaction  similaires). On peut  les scruter  en même
    temps
  \item Utilisation du CPU sous optimal. Beaucoup de temps est utilisé
    pour lire la valeur des  entrée. Ceci est particulièrement vrai si
    les évènements sont peu fréquents
  \item Si certains évènements entrainent des temps de traitement long
    ou si il y a beaucoup  d'entrées à scruter, le temps de réponse en
    pire cas peut rapidement devenir très grand
  \item Tous les évènements sont traité avec la même priorité
  \item  Mauvaise modularité  du code.  Ajouter des  des périphériques
    revient à repenser tout le système
  \end{itemize} 
\end{frame} 

\section{Gestion d'interruptions synchrones} 

\begin{frame}{Interruptions synchrones}
  \begin{itemize} 
  \item Appellé aussi Background/Foreground
  \item Gestion des évènements dans les interruptions
  \end{itemize} 
  \begin{center}
    \pgfimage[width=6cm]{pics/model_bgfg.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Interruptions synchrones}
  Concrètement:
  \begin{lstlisting}
#define sensor1 *((char *) 0x1234)

void interrupt() {
  action1();
}

int main() {
  enable_interrupt(interrupt, 0x1);
  while(1) {
// Optionnal background computing 
  }
}
  \end{lstlisting} 
\end{frame}

\begin{frame}{Interruptions synchrones}
  \begin{itemize} 
  \item Temps de réponse au évènements plutôt bon
  \item Temps de réponse assez simple à calculer. Somme de 
    \begin{itemize}
    \item Temps de traitement de l'évenement
    \item Temps de traitement des évènemnts de priorité supérieures
    \item Temps du changement de contexte (plus ou moins constant)
    \item Pire interval de temps ou les interruptions sont désactivée 
    \end{itemize} 
  \item[$\rightarrow$] Dans  un système simple, ca peut  se calculer à
    la louche
  \item Le  temps de réponse en pire  cas des calcul en  tâche de fond
    est quasiement  identique au traitement  par scrutation (attention
    tout de même à la fréquence maximum des interruptions)
  \end{itemize} 
\end{frame} 

\begin{frame}{Qu'est-ce qu'une interruption?}
  Il existe trois type d'interruptions:
  \begin{itemize} 
  \item Les interrruption matérielles:
    \begin{itemize} 
    \item        IRQ         (aussi        appellé        Interruption
      externe).  Asynchrone.  Exemples:  clavier, horloge,  bus,  DMA,
      second processeur, etc...
    \item Exception.  Asynchrone ou Synchrone.  Exemples: Division par
      zéro,   Erreur   arithmétique,   Erreur  d'instruction,   Erreur
      d'alignement, Erreur de page, Breakpoint matériel, Double faute,
      etc...
      \note{Une overflow  arithmétique ne produit  pas d'exception, il
        lève le flags ``retenue''}
      \note{Un  breakpoint  logiciel change  une  instruction par  une
        interruption  logicielle. Un  break point  software  n'est pas
        possible en ROM alors que le breakpoint hardware oui}
    \end{itemize} 
  \item Logicielle. Déclenché par une instruction. Synchrone.
  \end{itemize}
\end{frame} 

\begin{frame}{Fonctionnement d'une interruption}
  Quand une  interruption est levée:
  \begin{itemize} 
  \item le CPU sauve en  partie ou en totalité le contexte d'execution
    (principalement le pointeur d'instruction) sur la pile
  \item Le CPU passe en mode superviseur (nous y reviendrons)
  \item  Le CPU  recherche dans  l'IVT (\emph{Interrupt  Vector Table}
    aussi  appellé  IDT,  \emph{Interrupt  Description  Table})  l'ISR
    (\emph{Interruption Service Routine}) associée
  \item Le CPU place le pointeur d'instruction sur l'ISR
  \item  L'ISR traite  l'évènement (fin  de traitement  d'une E/S,
    etc...)
  \item L'ISR acquite la  réception de l'interruption indiquant qu'une
    nouvelle  donnée peut-être  traitée.
  \item L'ISR restore le (un) contexte
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Fonctionnement d'une interruption} 
  \begin{center}
    \pgfimage[width=10cm]{pics/interuption-1.png}
  \end{center}
\end{frame}  

\begin{frame}{Fonctionnement d'un PIC}
  Le PIC (Programmable Interrupt Controller) est un composant matériel
  permettant  la gestion  des  IRQ.  Il peut-être  intégré  au CPU  ou
  externe (ou à cheval entre les deux...). Il permet en particulier:
  \begin{itemize}
  \item Activer ou de désactiver des IRQ
  \item De masquer temporairement une IRQ
  \item De mettre en queue une interruption temporairement masquée
  \item De controller la priorité des interruptions
  \end{itemize} 
  Il arrive fréquement  qu'un PIC soit multiplexé sur  une seule ligne
  d'IRQ. Dans  ce cas, le premier  étage d'ISR lit un  registre du PIC
  pour connaitre  le numéro de l'IRQ.   (Cas notoire du  8259A sur les
  architectures x86)

  \note {Il existe aussi des APIC (Advanced PIC). Sur PC notament}
\end{frame} 

\begin{frame}{Exemple}
  Exemple classique d'intégration d'un PIC multiplexé sur une IRQ:
  \begin{center}
    \pgfimage[width=10cm]{pics/interuption-3.png}
  \end{center}
\end{frame} 

\begin{frame}{Exemple}
  \begin{enumerate}
  \item Le périphérique \emph{Timer} lève sa ligne d'IRQ
  \item Le PIC recoit l'interruption et lève une IRQ du processeur
  \item  Le processeur  complète  l'instruction courante  et sauve  le
    registre d'instruction (PC) et le registre d'état (PSW)
  \item La tâche courante devient interrompue (Nous y reviendrons)
  \item Le premier étage d'ISR est appellé
  \item  Le  gestionnaire d'interruption  complète  la sauvegarde  des
    registres
  \item   Le  gestionnaire  d'interruption   demande  au   PIC  quelle
    interruption à  été appellée et il  lit dans l'IVT  quelle ISR est
    associée
  \end{enumerate}
\end{frame}

\begin{frame}{Exemple}
  \begin{enumerate}
  \item Le  gestionnaire d'interruption se branche  sur l'ISR associée
    (ici, ISR1)
  \item L'IRQ du processeur est  acquitée. Les autre IRQ peuvent ainsi
    être levées
  \item L'ISR1 lit lit la  valeur provenant du \emph{Timer} et acquite
    l'interruption  du \emph{Timer}. Ce  périphérique peut  de nouveau
    lever des IRQ.
  \item Les registres généraux sont restaurés
  \item Le contexte d'éxecution est restauré
  \item Le registre PC est restauré
  \end{enumerate}
\end{frame} 

\subsection{Utilisation des interruptions}

\begin{frame}{Exemple}
  Exemple de différence d'approche entre la gestion par scrutation et 
  la gestion par interruption:\\

  Prennons  l'acquisition  de   donnée  à  partir  d'un  convertisseur
  analogique/numérique asynchrone
  \begin{itemize}
  \item  Dans  le  cas  du  traitement  par  scrutation,  nous  allons
    periodiquement voir  si un résultat est arrivé.  Beaucoup de temps
    est  consommé  pour  rien   et  lorsque  le  résultat  arrive,  le
    traitement du résultats sera retardé
  \item  Une interruption  est  levée quand  une  nouvelle donnée  est
    disponible. Le processeur peut alors la traiter.
  \end{itemize}
\end{frame} 

\begin{frame}{Latence des interruptions}
  \begin{itemize} 
  \item Un périphérique ne génère pas d'IRQ si la précédante n'est pas
    acquitée (en principe)
  \item Vu  les que les  interruptions sont souvent  multiplexées, les
    interruptions sont  souvent désactivées lors de  la première phase
    de traitement
  \item  Pour des  raisons techniques,  il est  parfois  nécessaire de
    désactiver les interruptions
  \item  Le partage  de l'information  entre les  interruptions  et le
    reste   du   programme  nécessite   parfois   de  désactiver   les
    interruptions (Nous y reviendrons)
  \end{itemize} 
  Les conséquences:
  \begin{itemize} 
  \item Augmente les temps de réponses
  \item Temps réponse plus difficile à calculer
  \item  Risque   de  perdre  des  interruption  (Dans   ce  cas,  une
    interruption \emph{overrun} est (devrait être) déclenchée)
  \end{itemize} 
  \note{Reprendre ici le cours de l'université de Montréal}
\end{frame} 

\begin{frame}{Precautions avec les interruption}
  \begin{itemize} 
  \item Acquiter l'interruption le plus tot possible
  \item Rester le moins de temps possible dans dans une interruption
  \item Accèder à un minimum de données pour eviter d'avoir à partager
    des données avec le background
  \item Transferer un maximum de traitement hors de l'interruption
  \item[$\rightarrow$] Gestion des interruption asynchrone
  \end{itemize} 
\end{frame} 

\section{Gestion d'interruptions asynchrones} 

\begin{frame}[fragile]{Interruptions asynchrones}
  \begin{itemize} 
  \item  Interruption  séparée en  deux  parties:  \emph{top half}  et
    \emph{bottom half}
  \item On délègue le maximum de traitement au \emph{bottom half}
  \item Permet de décharger les interruptions
  \item Permet  de plus facilement prendre en  compte des intéractions
    entre  les   évènements  (exemple,  possibilité   d'attendre  deux
    évènements avant d'effectuer une action)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Interruptions asynchrones}
  \begin{lstlisting} 
#define sensor1 *((char *) 0x1234)

int gotit = 0;
void interrupt() {
    gotit++;
    *PTR_DEVICE_ACK = 1;
}

int main() {
  enable_interrupt(interrupt, 0x1);
  while(1) {
     if (gotit) {
       gotit--;
       action1();
     }
// Optionnal background computing 
  }
}
  \end{lstlisting} 
  \note{Il y a un bug à cause  du partage de gotit, mais on en parlera
    plus tard}
  \note{Je suis embêté. Est-ce que je triate ca ici moi? Oui, voir le cours de Montreal}
\end{frame} 

%%%% EDIT THERE %%%%%%%

\begin{frame}{Partage de l'information}
  Partage d'information avec des interruptions:
  \begin{itemize} 
  \item  operation atomique
  \item  buffer ciculaires et queue
  \item  désactivation des interruptions
  \end{itemize} 
  \begin{itemize} 
  \item Utilisation  de structures de  partage de données  sans mutex:
    buffer circulaire et queue
  \item Les sections critiques  doivent être faites en désactivant les
    interruption (attention à la lattence induite, cf slide précédant)
  \end{itemize} 
\end{frame} 

\begin{frame}{Cas des interruption en milieu multi coeur}
  \begin{itemize} 
  \item On ne désactive que les interruption locale
  \item Une interruption peut se produire sur un autre coeur
  \item Nécessité d'utiliser un mécanisme supplémentaire d'exclusion
  \item \emph{Spin lock} suvent utilisé pour ce cas.
  \item  Pas beaucoup  d'autres  choix.  Par  conséquent les  sections
    critiques dans les interruptions doivent être très limitées
  \end{itemize} 
\end{frame} 

\begin{frame}{Problèmes de la gestion des interruption asynchrone}
  Nous n'avons pas résolu notre problème récurent:
  \begin{itemize} 
  \item  Le partage  de l'information  entre les  interruptions  et la
    boucle principale entraine des latences
  \end{itemize} 
  On retrouve certains problèmes que l'on avait avec la scrutation:
  \begin{itemize} 
  \item  Ne permet  pas de  prioriser  les traitement  dans la  boucle
    principale
  \item Interaction entre les évènements complexe
  \end{itemize} 
  \note{Parler du mot clef volatile} 
  \note{Montrer ici  le code du HC08  de la Cobalt.  Commencer par une
    description du but,  du hard: 3 ADC pour  Joystick, deux encodeur,
    clavier matricé,  bus can, prise coaxiale, 20ms,  sytème pour deux
    Cobalt   sur   un  même   réseau   montrer  doc/cobalt/schema   de
    principe.pdf.   Montrer MC68HC908GZ16.h  (montrer  les registres),
    MC68HC908GZ16.c   (montrer   volatile),   link.prm  (montrer   les
    vecteurs),   start.c  (copie  ROM   vers  RAM),   interrupt.c  (en
    particulier intGenlock), main.c (fonction loop)}
\end{frame} 



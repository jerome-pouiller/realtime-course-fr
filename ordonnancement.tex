%                                                                                                                       
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2011-08-14 17:43:38+02:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

% Il faut commencer par la, c'est le plus simple: priorités
% statiques, préemption, RR, RM, EDF, Background, Serveur
% scrutation, Serveur différé, Serveur sporadique

\part{Ordonnancement}

\section{Quelques notions théoriques}

\subsection{Modèle de tâches}

\begin{frame}{Modèle de tâches}
  Paramètres définissant une tâche $i$:
  \begin{itemize}
    \item Date d'arrivée de la tâche dans le système : $S_i$
    \item Première date d'activation : $R_i$
    \item Période d'activation : $T_i$
    \item Délai critique (délai maximum acceptable pour son exécution)
      : $D_i$
    \item Capacité (Temps CPU nécessaire à l'éxecution de la tâche) :
      $C_i$
  \end{itemize}
  \note{Ajouter le schéma de Touchard}
\end{frame}

\begin{frame}{Modèle de tâches}
  \begin{center}
  \begin{tikzpicture}[scale=0.75]
   %\draw[xstep=1,ystep=0.1,gray,very thin] (0,0) grid (#1.5,#2);
   \draw[->, line width=1pt] (0,-2) -- (14.5,-2) coordinate (x axis);
   \draw[line width=1pt] (0,-2) -- (0,0) coordinate (x axis);
   \foreach \x in {0,1,...,14}
      \draw (\x,-2) node[anchor=north] {\tiny\x};
   \fill[cgreen]  (0,-1.5) \lo 3 \hi 2 \lo 3 \hi 1 \lo 1 \hi 1 \lo 2;
   \foreach \i in {2, 8}
      \pb{\i}{-1}{cgreen};
   \foreach \i in {7, 13}
      \pe{\i}{-1}{cgreen};
   \draw (-0.5,-1) node {$i$};
   \draw (1,-2.1) -- (1,1.2) node[above] {$S_i$};
   \draw (2,-2.1) -- (2,1.2) node[above] {$R_i$};
   \draw (7,-2.1) -- (7,0.6);
   \draw (8,-2.1) -- (8,1.2);
   \draw (13,-2.1) -- (13,0.6);
   \draw (14,-2.1) -- (14,1.2);
   \draw[<->] (2,-.3) -- (5,-.3) node[above=-0.1,pos=0.5] {$TR_{1i}$};
   \draw[<->] (2,0.3) -- (7,0.3) node[above=-0.1,pos=0.5] {$D_i$};
   \draw[<->] (2,0.9) -- (8,0.9) node[above=-0.1,pos=0.5] {$T_i$}; 
   \draw[<->] (8,-0.3) -- (12,-0.3) node[above=-0.1,pos=0.5] {$TR_{2i}$};
   \draw[<->] (8,0.3) -- (13,0.3) node[above=-0.1,pos=0.5] {$D_i$};
   \draw[<->] (8,0.9) -- (14,0.9) node[above=-0.1,pos=0.5] {$T_i$};
 \end{tikzpicture}

    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      $i$ & 2 & 6 & 2 & 5\\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Modèle de tâches}
  Par conséquent: 
  \begin{itemize} 
  \item Tâche périodique définie par : $(S_i, R_i, T_i ,D_i, C_i)$
  \item Tâche apériodique définie par : $(S_i, R_i, 0, D_i, C_i)$
  \end{itemize} 
  Très souvent:
  \begin{itemize}
    \item Les tâches sont connues début de l'ordonnacement : $S_i = 0$
    \item Les tâches périodique sont actives dès le début de
      l'ordonnancement : $R_i = 0$
    \item L'échéance des  tâches périodique est leur période  : $D_i =
      T_i$
  \end{itemize}
\end{frame}

\begin{frame}{Modèle de tâches}
  Paramètres statiques:
  \begin{itemize} 
  \item Date de réveil sur une période $k$ : $r_{ik}$
  \item Echéance sur une période $k$ : $d_{ik} = r_{ik} + D_i$
  \item Facteur d'utilisation du processeur: $U_i =  C_i / T_i$
  \item Facteur de charge du processeur : $CH_i = C_i / D_i $ ($CH_i =
    U_i$ si échéance sur périodes)
  \item Laxité de la tâche (retard maximum acceptable pour l'exécution
    de la tâche) : $L_i = D_i - C_i$
  \end{itemize} 
\end{frame}

\begin{frame}{Modèle de tâches}
  Paramètres dynamiques (dépendant de l'ordonnancement):
  \begin{itemize} 
  \item Priorité (peut être dynamique ou statique) : $P_i$
  \item Date du début de l'exécution d'une période $k$ : $s_{ik}$
  \item Date de la fin de l'exécution d'une période $k$ :$e_{ik}$
  \item Temps de réponse de la tâche $TR_{ik} = e_{ik} - r_{ik}$ (Nous
    verrons comment le calculer)
    % = C_i + \sum_{prio(j) > prio(i)} \left\lceil\frac{TR_i}{P_j}\right\rceil C_j$
  \item Durée d'exécution résiduelle à la date $t$ : $C_i(t)$ ($0 ≤
    C_i(t) ≤ C_i$)
  \item Délai  critique résiduel à la  date $t$ :  $D_i(t) = d_{ik}-t$
    ($0 ≤ D_i(t) ≤ D_i$)
  \item Charge résiduelle à la date $t$ :
    $CH_i(t) = C_i(t) / D_i(t)$  ($0 ≤ CH_i(t) ≤ CH_i$)
  \item Laxité  résiduelle à la  date $t$ :
    $L_i(t) = D_i(t) - C_i(t)$  ($0  ≤ L_i(t) ≤  L_i$)
  \item  Laxité conditionnelle  à la  date $t$  (somme sur  les tâches
    déclenchées à la  date $t$ et qui sont devant $i$  du point de vue
    de  l'ordonnancement)  :  $LC_i(t)  =  D_i(t)  -  \sum_{P_j  >
      P_i} C_j(t)$ ($0 ≤ LC_i(t) ≤ L_i$)
  \end{itemize} 
\end{frame}

\note{Peut-etre ajouter slide 5 de Touchar}
\note{J'ai placé le slide 7 avant le slide 6 de touchard}

\begin{frame}{Paramètres du système}
  \begin{itemize} 
  \item  Configuration  :  ensemble   des  tâches  mises  en  jeu  par
    l'application
  \item Taux d'utilisation du processeur : $U = \sum_i U_i$
  \item Taux de charge du processeur : $CH = \sum_i CH_i$
  \item Intervalle d'étude :  intervalle de temps minimum pour prouver
    l'ordonnançabilité  d'une  configuration
    \begin{itemize} 
    \item  Dans  le  cas de  tâches périodiques: $ppcm_i(T_i)$
    \item  Dans le cas  de tâches  apériodiques: $\left[\min_i\{R_i\},
        \max_i\{R_i + D_i\} + 2 \times ppcm_i(T_i)\right]$
    \end{itemize} 
  \item Laxité du  processeur : intervalle de temps  pendant lequel le
    processeur peut rester inactif  tout en respectant les échéances :
    $ LP(t) = \min_i\{LC_i(t)\}$
  \end{itemize} 
\end{frame} 

\begin{frame}{Etats des tâches}
  \begin{center}
    \begin{tikzpicture}[scale=2]
      \tikzstyle{block} = [rectangle, draw, fill=blue!20, 
        text width=5em, text centered, rounded corners, minimum height=4em]
      \tikzstyle{io} = [ellipse, draw, fill=red!20]

      \node[block]             (Ru)  {Running};
      \node[block,above=of Ru] (Wa)  {Waiting};
      \node[io,   right=of Ru] (Out) {};
      \node[block,below=of Ru] (Int) {Interrupted};
      \node[block,left=of Ru]  (Re)  {Ready};
      \node[io,   left=of Re]  (In)  {};
      \draw[->] (Re)  -- (Ru);
      \draw[->] (Ru)  -- (Wa);
      \draw[->] (Ru)  -- (Int);
      \draw[->] (Int) -- (Ru);
      \draw[->] (Int.north west) -- (Re.south);
      \draw[->] (Wa.south west)  -- (Re.north);
      \draw[->] (Ru)  -- (Out);
      \draw[->] (In)  -- (Re);
    \end{tikzpicture}
  \end{center}
\end{frame} 

\subsection{Théroème de l'instant critique}

\begin{frame}{Théorème de l'instant critique}
  Si toutes les  tâches arrivent initialement dans le  système en même
  temps et  si elles respectent  leur première échéance,  alors toutes
  les  échéances  seront  respectées  par  la  suite,  quel  que  soit
  l'instant d'arrivée des tâches.

  \begin{itemize}
  \item  C'est une condition  nécessaire et  suffisante si  toutes les
    tâches du système sont initialement prêtes au même instant.
  \item Dans le cas contraire, c'est une condition suffisante
  \end{itemize}

  Si $D_i = T_i$, le test de terminaison est :
  $$\forall i, 1 ≤ i ≤ n \;\;\;\min_{0 ≤ t ≤ D_i}
  \sum_{j=1}^i\frac{C_j}{t}
  \left\lfloor\frac{t}{T_j}\right\rfloor ≤ 1$$
\end{frame}

\subsection{Temps de réponse}

\begin{frame}{Temps de réponse}
  Délai entre l'activation d'une tâche et sa terminaison. 

  $$TR_i = C_i + \sum_{P_j > P_i} \left\lceil\frac{TR_i}{T_j}\right\rceil C_j$$

\end{frame}

\begin{frame}{Calcul du temps de réponse}
  Technique de calcul : on évalue de façon itérative
  $$w_i^{n+1}=C_i+\sum_{P_j > P_i} \left\lceil\frac{w_i^n}{T_j}\right\rceil C_j$$

  \begin{itemize}
    \item On démarre avec $w_i^0 = C_i$
    \item Echec si $w_i^n > T_i$
    \item Réussite si $w_i^{n+1} = w_i^n$
  \end{itemize}
\end{frame} 

\begin{frame}{Calcul du temps de réponse}
  \textbf{Exemple :}
  \begin{center}
    \begin{tabular}{cccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance & Priorité \\
      \hline
      A & 0 &  7 & 3 & Fin de période & 1\\
      B & 0 & 12 & 2 & Fin de période & 2\\
      C & 0 & 20 & 5 & Fin de période & 3\\
      \hline
    \end{tabular}
  \end{center}
  \begin{columns}
    \begin{column}{5cm}
      \begin{align*}
        w_1^0 &= C_1 = 3\\
        w_2^0 &= C_2 = 2\\
        w_2^1 &= 2 + 3 \left\lceil\frac{2}{7}\right\rceil = 5\\
        w_2^2 &= 2 + 3 \left\lceil\frac{5}{7}\right\rceil = 5\\
        w_3^0 &= C_3 = 5\\
        w_3^1 &= 5 + 3 \left\lceil\frac{5}{7}\right\rceil + 2 \left\lceil\frac{5}{12}\right\rceil = 10\\
      \end{align*} 
    \end{column}
    \begin{column}{5cm}
      \begin{align*}
        w_3^2 &= 5 + 3 \left\lceil\frac{10}{7}\right\rceil + 2 \left\lceil\frac{10}{12}\right\rceil = 13\\
        w_3^3 &= 5 + 3 \left\lceil\frac{13}{7}\right\rceil + 2 \left\lceil\frac{13}{12}\right\rceil = 15\\
        w_3^4 &= 5 + 3 \left\lceil\frac{15}{7}\right\rceil + 2 \left\lceil\frac{15}{12}\right\rceil = 18\\
        w_3^5 &= 5 + 3 \left\lceil\frac{18}{7}\right\rceil + 2 \left\lceil\frac{18}{12}\right\rceil = 18\\
      \end{align*} 
    \end{column}
  \end{columns}
\end{frame}

\section{Algorithmes à priorité statique}

\begin{frame}{Typologie des algorithmes}
  On distingue diverse typologie d'algorithmes:
  \begin{itemize}
  \item  \emph{on  line}  ou   \emph{off  line}:  Choix  dynamique  ou
    prédéfini à la conception
  \item  à priorité \emph{statique}  ou \emph{dynamique}:  La priorité
    d'une  tâche est-elle  fixe  ou une  variable dépendante  d'autres
    paramètres 
  \item \emph{préemptif} ou  \emph{non préemptif}: Une tâche peut-elle
    perdre le  processeur (au profit d'une tâche  plus prioritaire) ou
    non
  % \item stratégie du meilleur effort ou inclémence
  %   \begin{itemize}
  %   \item  en  TR mou,  meilleur  effort =  faire  au  mieux avec  les
  %     processeurs disponibles
  %   \item  en  TR  dur,   obligation  des  respecter  les  contraintes
  %     temporelles : inclémence aux fautes temporelles
  %   \end{itemize}
  %\item centralisé ou réparti
  \end{itemize}
\end{frame}

% \begin{frame}{Round-Robin}
% TODO
% \end{frame} 

\subsection{Rate Monotonique (RM)}

\begin{frame}{Rate Monotonique}
  Ordonnancement à priorité statique où les priorité sont inversement
  proportionnelles aux périodes des tâches. 

  Fonctionne  en version préemptive.  La version  non-préemptive n'est
  pas garantie.

  Liu et Layland ont démontré qu'un système est ordonnançable si le
  taux d'occupation du processeur $U$ vérifie la condition suffisante
  (non nécessaire) suivante :

  \begin{columns}
    \begin{column}{5cm}
      $$U = \sum_i^n \frac{C_i}{T_i} ≤ n \left(2^{\frac{1}{n}}-1\right)$$
    \end{column}
    \begin{column}{5cm}
      \begin{center}
        \begin{tabular}{cc}
          \hline
          $n$ & limite d'occupation \\
          \hline
          1 & 100.0\% \\
          2 & 82.8\% \\
          3 & 78.0\% \\
          4 & 75.7\% \\
          5 & 74.3\% \\
          10 & 71.9\% \\
          $\infty$ & 69.3\%\\
          \hline
        \end{tabular}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Exemple 1}
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 8 & Fin de période\\
      B & 0 & 10 & 1 & Fin de période\\
      C & 0 &  4 & 1 & Fin de période\\
      \hline
    \end{tabular}
  \end{center}
  Charge du CPU:
  $$\frac{8}{40} + \frac{1}{10} + \frac{1}{4} = 0.75$$
\end{frame} 

\begin{frame}{Exemple 1}
  Mode préemptif ($ppcm(4, 10, 20) = 20$):\\ 
  % CBAACAAACABACAAACXXX
  \begin{tikzpicture}[scale=0.5]
    \timeline{20}{-5}{-1.0/A, -2.5/B, -4.0/C}
    \fill[cgreen] (0,-1.5) \lo 1 \lo 1 \hi 2 \lo 1 \hi 3 \lo 1 \hi 1 \lo 1 \hi 1 \lo 1 \hi 3 \lo 1 \lo 3 \lo 1;
    \fill[cred]   (0,-3.0) \lo 1 \hi 1 \lo 2 \lo 1 \lo 3 \lo 1 \lo 1 \hi 1 \lo 1 \lo 1 \lo 3 \lo 1 \lo 3 \lo 1;
    \fill[cblue]  (0,-4.5) \hi 1 \lo 1 \lo 2 \hi 1 \lo 3 \hi 1 \lo 1 \lo 1 \lo 1 \hi 1 \lo 3 \hi 1 \lo 3 \hi 1;

    \pb{0}{-1}{cgreen};
    \p{20}{-1}{cgreen};
    \pb{0}{-2.5}{cred};
    \p{10}{-2.5}{cred};
    \p{20}{-2.5}{cred};
    \pb{0}{-4}{cblue};
    \p {4}{-4}{cblue};
    \p {8}{-4}{cblue};
    \p{12}{-4}{cblue};
    \p{16}{-4}{cblue};
    \p{20}{-4}{cblue};
    \end{tikzpicture}
    \\
    Mode non-préemptif :\\ 
    % CBAAAAAAAAAACCCBXCXXX
    \begin{tikzpicture}[scale=0.5]
      \timeline{20}{-5}{-1.0/A, -2.5/B, -4.0/C}
      \fill[cgreen] (0,-1.5) \lo 1 \lo 1 \hi{10} \lo 3 \lo 1 \lo 1 \lo 1 \lo 2 \lo 1;
      \fill[cred]   (0,-3.0) \lo 1 \hi 1 \lo{10} \lo 3 \hi 1 \lo 1 \lo 1 \lo 2 \lo 1;
      \fill[cblue]  (0,-4.5) \hi 1 \lo 1 \lo{10} \hi 3 \lo 1 \lo 1 \hi 1 \lo 2 \hi 1;

    \pb{0}{-1}{cgreen};
    \p{20}{-1}{cgreen};
    \pb{0}{-2.5}{cred};
    \p{10}{-2.5}{cred};
    \p{20}{-2.5}{cred};
    \pb{0}{-4}{cblue};
    \p {4}{-4}{cblue};
    \p {8}{-4}{cblue};
    \p{12}{-4}{cblue};
    \p{16}{-4}{cblue};
    \p{20}{-4}{cblue};
    \draw (8, -4) node {\textcolor{red!80}{\huge{$\times$}}};
    \draw (12, -4) node {\textcolor{red!80}{\huge{$\times$}}};
    \end{tikzpicture}
\end{frame}

\begin{frame}{Exemple 2}
    \begin{center}
      \begin{tabular}{ccccc}
        \hline
        Tâche & Arrivée & Période & Capacité & Echéance \\
        \hline
        A & 0 & 16 & 8 & Fin de période\\
        B & 0 &  8 & 2 & Fin de période\\
        C & 0 &  4 & 1 & Fin de période\\
        \hline
      \end{tabular}
    \end{center}
    $$\frac{8}{16} + \frac{2}{8} + \frac{1}{4} = 1$$
    \input{RM-2.pgf}
\end{frame}

\subsection{Deadline Monotonic}
\note{ajouter un exemple montrant la différence entre les deux}

\begin{frame}{Deadline Monotonic (DM)} 
  \begin{itemize}
  \item Algorithme à priorité statique
\item Généralisation de Rate Monotonic aux tâches à échéance sur requête
  \item Basé sur le délai critique :
    \begin{itemize}
    \item La tâche de plus petit délai critique est la plus prioritaire
    \end{itemize}
\item Test d'acceptabilité:
  $$U = \sum_i^n \frac{C_i}{D_i} ≤ n \left(2^{\frac{1}{n}}-1\right)$$
  \item Equivalent à Rate Monotonic  dans le cas des tâches à échéance
    sur requête, meilleur dans les autres cas
  \end{itemize}
\end{frame}

\begin{frame}{Exemple}
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & 7\\
      B & 0 &  5 & 2 & 4\\
      C & 0 & 10 & 2 & 9\\
      \hline
    \end{tabular}
  \end{center}
\end{frame} 

\begin{frame}{Exemple}
  Par RM:
  $$\frac{3}{20} + \frac{2}{5} + \frac{2}{10} = 0.75$$
  % BBCCABBAAXBBCC
  \begin{tikzpicture}[scale=0.5]
    \timeline{15}{-5}{-1.0/A, -2.5/B, -4.0/C}
    \fill[cgreen] (0,-1.5) \lo 2 \lo 2 \hi 1 \lo 2 \hi 2 \lo 1 \lo 2 \lo 2;
    \fill[cred]   (0,-3.0) \hi 2 \lo 2 \lo 1 \hi 2 \lo 2 \lo 1 \hi 2 \lo 2;
    \fill[cblue]  (0,-4.5) \lo 2 \hi 2 \lo 1 \lo 2 \lo 2 \lo 1 \lo 2 \hi 2;
    \pb{0}{-1}{cgreen};
    \pe{7}{-1}{cgreen};
    \pb{0}{-2.5}{cred};
    \pe{4}{-2.5}{cred};
    \pb{5}{-2.5}{cred};
    \pe{9}{-2.5}{cred};
    \pb{10}{-2.5}{cred};
    \pe{14}{-2.5}{cred};
    \pb{0}{-4}{cblue};
    \pe{9}{-4}{cblue};
    \pb{10}{-4}{cblue};

    \draw (7, -1) node {\textcolor{red!80}{\huge{$\times$}}};
  \end{tikzpicture}
\end{frame}

\begin{frame}{Exemple}
  Par DM:
  $$\frac{3}{7} + \frac{2}{4} + \frac{2}{9} = 1.15$$
  % BBAAABBCCXBBCC
  \begin{tikzpicture}[scale=0.5]
    \timeline{20}{-5}{-1.0/A, -2.5/B, -4.0/C}
    \fill[cgreen] (0,-1.5) \lo 2 \hi 3 \lo 2 \lo 2 \lo 1 \lo 2 \lo 2;
    \fill[cred]   (0,-3.0) \hi 2 \lo 3 \hi 2 \lo 2 \lo 1 \hi 2 \lo 2;
    \fill[cblue]  (0,-4.5) \lo 2 \lo 3 \lo 2 \hi 2 \lo 1 \lo 2 \hi 2;
    \pb{0}{-1}{cgreen};
    \pe{7}{-1}{cgreen};
    \pb{0}{-2.5}{cred};
    \pe{4}{-2.5}{cred};
    \pb{5}{-2.5}{cred};
    \pe{9}{-2.5}{cred};
    \pb{10}{-2.5}{cred};
    \pe{14}{-2.5}{cred};
    \pb{0}{-4}{cblue};
    \pe{9}{-4}{cblue};
    \pb{10}{-4}{cblue};
  \end{tikzpicture}
\end{frame} 

\section{Algorithmes à priorité dynamique}

\subsection{Earliest Deadline First (EDF)}

\begin{frame}{Algorithme EDF}
  \begin{itemize}
  \item Algorithme à priorité dynamique
  \item Basé sur l'échéance :
    \begin{itemize}
    \item A chaque instant (i.e à chaque réveil de tâche), la priorité
      maximale  est donnée  à la  tâche  dont l'échéance  est la  plus
      proche
    \end{itemize}
  \item Test d'acceptabilité:
    \begin{itemize}
    \item Condition nécessaire:
      $$U = \sum_i^n \frac{C_i}{T_i} ≤ 1$$
    \item Condition suffisante:
      $$U = \sum_i^n \frac{C_i}{D_i} ≤ 1$$
    \item  Dans le  cas  de tâche  à  échéance sur  requête, les  deux
      conditions sont égales
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Exemple}
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & 7\\
      B & 0 &  5 & 2 & 4\\
      C & 0 & 10 & 2 & 8\\
      \hline
    \end{tabular}
  \end{center}
    $$\frac{3}{20} + \frac{2}{5} + \frac{2}{10} = 0.75 ≤ 1$$
    $$\frac{3}{7} + \frac{2}{4} + \frac{2}{9} = 1.15 > 1$$
    Par DM:
    \input{EDF-1.pgf}
    Par EDF:
    % BBAAACCBBXBBCCXBBXXX
    \begin{tikzpicture}[scale=0.5]
      \timeline{20}{-5}{-1.0/A, -2.5/B, -4.0/C}
      \fill[cgreen] (0,-1.5) \lo 2 \hi 3 \lo 2 \lo 2 \lo 1 \lo 2 \lo 2 \lo 1 \lo 2 \lo 3;
      \fill[cred]   (0,-3.0) \hi 2 \lo 3 \lo 2 \hi 2 \lo 1 \hi 2 \lo 2 \lo 1 \hi 2 \lo 3;
      \fill[cblue]  (0,-4.5) \lo 2 \lo 3 \hi 2 \lo 2 \lo 1 \lo 2 \hi 2 \lo 1 \lo 2 \lo 3;
    \pb{0}{-1}{cgreen};
    \pe{7}{-1}{cgreen};
    \pb{0}{-2.5}{cred};
    \pe{4}{-2.5}{cred};
    \pb{5}{-2.5}{cred};
    \pe{9}{-2.5}{cred};
    \pb{10}{-2.5}{cred};
    \pe{14}{-2.5}{cred};
    \pb{15}{-2.5}{cred};
    \pe{19}{-2.5}{cred};
    \pb{0}{-4}{cblue};
    \pe{8}{-4}{cblue};
    \pb{10}{-4}{cblue};
    \pe{18}{-4}{cblue};
    \end{tikzpicture}
\end{frame} 
  
\subsection{Least Slack Time (LST)}

\begin{frame}{Least Slack Time (LST)} 
  \begin{itemize}
  \item Algorithme à priorité dynamique
  \item Aussi appelé \emph{Least Laxity First (LLF)}
  \item   Amélioration   de  EDF.   Mêmes   propriétée,  mais   permet
    d'ordonnancer des problèmes non-ordonnancable par EDF.
  \item Basé sur la laxité résiduelle: 
    \begin{itemize}
    \item La  priorité maximale est  donnée à la  tâche qui a  la plus
      petite laxité résiduelle: $L(t) = D(t) - C(t)$
    \end{itemize}
  \item Equivalent à  EDF si on ne calcule la  laxité qu'au réveil des
    tâches
  \item Optimum à trouver entre  la granularité du calcul et le nombre
    de changements de  contexte provoqués 
    \note{Effectivement,  dans   un  EDF  ou  RM,   on  recalcule  que
      lorsqu'une tache revient dans l'ordonanceur (= lorsqu'elle passe
      de SLEEP  à RUN =sur evenement  = rare).  Ici il  faut choisr un
      quantum pour le  calcul de la laxité.  Néanmoins,  c'est deja ce
      qu'on fait des que l'on souhaite faire du round robin.}
  \end{itemize}
\end{frame}

\begin{frame}{Exemple}
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 1 & 7\\
      B & 0 &  5 & 2 & 3\\
      C & 0 & 10 & 3 & 8\\
      \hline
    \end{tabular}
  \end{center}
  Par EDF:
  \input{LST-1.pgf}
  Par LST, en recalculant l'algorithme à chaque période:
  \input{LST-2.pgf}
\end{frame} 

\begin{frame}{Exemple - 2}
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 17 & 5 & Fin de période\\
      B & 0 & 18 & 5 & Fin de période\\
      \hline
    \end{tabular}
  \end{center}
  Par EDF:
  \input{LST-3.pgf}
  Par LST, en recalculant l'algorithme à chaque période:
  \input{LST-4.pgf}
\end{frame} 

\section{Serveurs de tâches apériodiques}


\begin{frame}{Introduction} 
  \begin{itemize}
  \item Tâches prises en compte dans une configuration comprenant déjà
    des tâches périodiques
  \item A priori, on ne  connaît pas l'instant d'arrivée de la requête
    de réveil de la tâche apériodique
  \item Contraintes temporelles strictes ou relatives 
  \item Buts à atteindre : 
    \begin{itemize}
    \item Maintenir les garanties du temps réelles sur les tâches déjà
      présentes dans l'ordonnanceur
    \item Si contraintes relatives : minimiser le temps de réponse
    \item  Si contraintes  strictes :  maximiser le  nombre  de tâches
      acceptées en respectant leurs contraintes
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Execution en arrière-plan}

\begin{frame}{Traitement en arrière-plan} 
  \begin{itemize}
  \item Aussi appellé \emph{backgound} ou sur \emph{temps creux}
  \item tâches apériodiques ordonnancées quand le processeur est oisif 
    \begin{itemize}
    \item les tâches périodiques restent les plus prioritaires 
    \end{itemize}
  \item ordonnancement relatif des tâches apériodiques en mode FIFO 
  \item traitement le plus simple, mais le moins performant 
  \item Pas de  marge de manoeuvre pour améliorer  le temps de réponse
    des  tâches apériodique.  Potentiellement, les  tâches apériodique
    peuvent avoir des temps de réponse long.
  \end{itemize}
\end{frame}

\begin{frame}{Traitement en arrière-plan} 
  Avec ordonnancement RM des tâches périodiques:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 &  5 & 2 & Fin de période\\
      B & 0 & 10 & 2 & Fin de période\\
      1 & 0 &  3 & 2 & Aucune\\
      2 & 0 & 10 & 1 & Aucune\\
      3 & 0 & 11 & 2 & Aucune\\
      \hline
    \end{tabular}
  \end{center}
  \input{aperiod-bg.pgf}
  % AABB1AA1X2AABB1AA33
  % Temps de réponses:
  % 1: 4, 2: 5, 3: 9
\end{frame} 

\subsection{Traitement par serveur}

\begin{frame}{Traitement par serveur} 
  \begin{itemize}
  \item un  serveur est une  tâche périodique créée  spécialement pour
    prendre en compte les tâches apériodiques
  \item serveur caractérisé par :
    \begin{itemize}
    \item sa période 
    \item son temps d'exécution : capacité du serveur  
    \item serveur  généralement ordonnancé suivant  le même algorithme
      que les autres tâches périodiques
    \item une fois actif, le serveur sert les tâches apériodiques dans
      la limite de sa capacité.
    \item l'ordre de traitement  des tâches apériodiques ne dépend pas
      de l'algorithme général
    \end{itemize}
  \item Il est  possible de le combiner le  traitement avec un serveur
    avec   un   traitement   en   background   (Temps   de   réponse+,
    prédictabilité-)
  \end{itemize}
\end{frame}

\subsection{Serveur par scrutation}

\begin{frame}{Serveur par scrutation}
  \begin{itemize}
  \item Aussi appellé \emph{polling}
  \item A chaque activation,  traitement des tâches en suspens jusqu'à
    épuisement  de la capacité  ou jusqu'à  ce qu'il  n'y ait  plus de
    tâches en attente
  \item Si aucune tâche n'est  en attente (à l'activation ou parce que
    la  dernière  tâche  a  été  traitée)  ,  le  serveur  se  suspend
    immédiatement et perd sa capacité qui peut être réutilisée par les
    tâches périodiques
  \item Quand une instance (un événement) de tâche apériodique arrive,
    elle attend jusqu’à ce que la capacité du serveur soit disponible.
  \item  Il est  possible de  rendre la  main au  CPU si  aucune tache
    apériodique  n'est  en  attente  (TR  des  taches  periodiques  +,
    prédictabilité -)
  \item  Dans  le  cas  ou  le  serveur à  la  plus  petite  priorité,
    l'algorithme équivaut à peu près au traitement en background
  \end{itemize}
\end{frame} 

\begin{frame}{Exemple}
  A vide, avec ordonnancement RM des tâches périodiques:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & Fin de période\\
      B & 0 & 10 & 2 & Fin de période\\
      S & 0 &  5 & 2 & Fin de période\\
      \hline
    \end{tabular}
  \end{center} 
  % SSBBASSAAXSSBBXSS
 \input{aperiod-poll-1.pgf}
\end{frame} 

\begin{frame}{Exemple}
  Idem avec les 3 tâches apériodiques:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & Fin de période\\
      B & 0 & 10 & 2 & Fin de période\\
      S & 0 &  5 & 2 & Fin de période\\
      1 & 0 &  2 & 2 & Aucune\\
      2 & 0 &  9 & 1 & Aucune\\
      3 & 0 & 10 & 3 & Aucune\\
      \hline
    \end{tabular}
  \end{center}
  % SSBBA11AAX23BBX3S
\input{aperiod-poll-2.pgf}
\end{frame} 

\begin{frame}{Exemple}
  Idem, en utilisant les temps creux en plus:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & Fin de période\\
      B & 0 & 10 & 2 & Fin de période\\
      S & 0 &  5 & 2 & Fin de période\\
      1 & 0 &  2 & 2 & Aucune\\
      2 & 0 &  9 & 1 & Aucune\\
      3 & 0 & 10 & 3 & Aucune\\
      \hline
    \end{tabular}
  \end{center}
  % BBAAA11XXX23BBX3XXXX
\input{aperiod-poll-3.pgf}
\end{frame} 

\subsection{Serveur différé}

\begin{frame}{Limitation} 
  Limitations du serveur par scrutation 
  \begin{itemize}
  \item perte de la capacité si aucune tâche apériodique en attente
  \item si occurrence d'une tâche apériodique alors que le serveur est
    suspendu, il faut attendre la requête suivante
  \end{itemize}
\end{frame} 

\begin{frame}{Serveur différé}
  Aussi appellé serveur ajournable
  La fausse bonne idée
  Provoque des erreur d'ordonnancement
\end{frame}

\begin{frame}{Exemple}
  Avec ordonnancement RM:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 &  7 & 2 & Fin de période\\
      S & 0 &  6 & 3 & Fin de période\\
      1 & 21 & 0 & 6 & Aucune\\
      \hline
    \end{tabular}
  \end{center}
\end{frame}
\begin{frame}{Exemple}
  % BBAA11AXXX23BBX3
  \input{aperiod-diff-1.pgf}
  % Changer d'exemple, il ne fait aucune différence avec le serveur par scrutation
  % Hint: reprendre le cas d'execution dos à dos
  \note{Le fameux cas dos à dos}
\end{frame} 

\subsection{Serveur sporadique}

\begin{frame}{Serveur sporadique}
  \begin{itemize}
  \item  améliore le  temps de  réponse des  tâches  apériodiques sans
    diminuer  le  taux d'utilisation  du  processeur  pour les  tâches
    périodiques
  \item Très utilisé pour les  IHM car permet une meilleure expérience
    utilisateur
  \item comme le serveur différé mais 
    \begin{itemize}
    \item  ne retrouve  pas  sa capacité  à  période fixe,  mais à  un
      instant de réinitialisation égal  à la date courante additionnée
      de la période de réinitialisation
      \item la capacité retrouvée est égale à la capacité consommée 
      \end{itemize}
    \end{itemize}
\end{frame} 

\begin{frame}{Exemple}
  Avec ordonnancement RM:
  \begin{center}
    \begin{tabular}{ccccc}
      \hline
      Tâche & Arrivée & Période & Capacité & Echéance \\
      \hline
      A & 0 & 20 & 3 & Fin de période\\
      B & 0 & 10 & 2 & Fin de période\\
      S & 0 &  5 & 2 & Fin de période\\
      1 & 0 &  3 & 2 & Aucune\\
      2 & 0 &  9 & 1 & Aucune\\
      3 & 0 & 10 & 2 & Aucune\\
      \hline
    \end{tabular}
  \end{center}
\end{frame}
\begin{frame}{Exemple}
  % BBAA11AXXX23BBX3
  \input{aperiod-scrut-1.pgf}
  % Changer d'exemple, il ne fait aucune différence avec le serveur par scrutation
  % Hint: reprendre le cas d'execution dos à dos
\end{frame} 


